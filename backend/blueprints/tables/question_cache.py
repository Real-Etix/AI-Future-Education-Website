# backend/blueprints/tables/question_cache.py

from sqlalchemy import select, update, delete
from .database import db

class QuestionCache(db.Model):
    '''
    Define the structure of the question_cache table.
    The purpose is to temporary store the questions generated by the LLM to reduce its usage.
    '''

    __bind_key__ = 'chats_db' # Binds to the chat database
    __tablename__ = 'question_cache'
    id = db.Column(db.Integer, primary_key=True, nullable=False)
    chat_id = db.Column(db.Integer, db.ForeignKey('chats.id', ondelete='CASCADE'), nullable=False)
    question_status = db.Column(db.Integer, nullable=False)
    question = db.Column(db.String(1024))
    answer = db.Column(db.String(1024))

def exist_question_cache_record(chat_id):
    return db.session.execute(select(QuestionCache.chat_id).where(QuestionCache.chat_id == chat_id)).first() is not None

def store_question_answer_pairs(chat_id, questions, answers):
    '''
    Store the question-answer pairs into the cache to be used later in the chat.
    '''
    for i, (question, answer) in enumerate(zip(questions, answers)):
        new_pair = QuestionCache(chat_id=chat_id, question_status=i+1, question=question, answer=answer) # type: ignore
        db.session.add(new_pair)
        db.session.commit()
    return new_pair.id

def get_question(chat_id):
    '''
    Get the question in order of question_status.
    '''
    result = db.session.execute(
        select(QuestionCache.id, QuestionCache.question).filter_by(chat_id = chat_id).order_by(QuestionCache.question_status.asc())
    ).first()

    # Return None if no more question-answer pair.
    if result == None:
        return None
    
    [cache_id, question] = result
    db.session.execute(update(QuestionCache), [{'id': cache_id, 'question': None}])
    db.session.commit()
    return question

def get_answer(chat_id):
    '''
    Get the answer in order of question_status.
    If there is still a question on the same row, we output <code>None</code>.
    '''
    result = db.session.execute(
        select(QuestionCache.id, QuestionCache.question, QuestionCache.answer).filter_by(chat_id = chat_id).order_by(QuestionCache.question_status.asc())
    ).first()

    # Return None if no more question-answer pair.
    if result == None:
        return None
    
    [cache_id, question, answer] = result

    # Return None if it is the first question
    if question:
        return None
    
    db.session.execute(delete(QuestionCache).where(QuestionCache.id == cache_id))
    db.session.commit()
    return answer